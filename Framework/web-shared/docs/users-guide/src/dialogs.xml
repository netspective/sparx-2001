<chapter>
    <title>The User Interface: Dialogs</title>

    <section id="dialogs">
        <title>Overview</title>
        <para>
        The first step in developing a web application is giving the user the ability to
        enter data and retrieve data. &product-name;'s answer to this is the <emphasis>Dialog</emphasis> object; it is through the
        Dialogs that a user can create new data, edit existing data, and remove data. A &product-name; Dialog
        object provides a multitude of features such as client-side/server-side
        data verifications and validations, dialog state tracking, and skin association.
        </para>

        <para>
        Defining the dialog in the  <filename class="conf">WEB-INF/ui/dialog.xml</filename>  is
        the first step towards creating a dialog. Dialogs are defined with the <emphasis role="bold">&lt;dialog&gt;</emphasis> tag
        and each dialog must belong to a package of dialogs represented by <emphasis role="bold">&lt;dialogs&gt;</emphasis> tag.
        The following is a sample dialog entry from the <emphasis>web-cura</emphasis> sample application:
        <programlisting>
    &lt;dialogs package="train"&gt;
        &lt;dialog name="test" heading="Add Account"&gt;
            &lt;field.text name="org_code" caption="Account Code" required="yes" default="request:myval"/&gt;
            &lt;field.select name="org_type" caption="Type" style="multidual" choices="query:org.enum-types-all"/&gt;
            &lt;field.integer name="employees" caption="Employees" min="10" max="20"/&gt;
        &lt;/dialog&gt;
    &lt;/dialogs&gt;
        </programlisting>

        </para>
    </section>

    <section id="Dialogs-DataFields">
        <title>Data Fields</title>
        <para>
        One can think of a dialog as a container/manager object consisting of data fields which have their own
        behaviors and properties. These data fields provide the flexibility to create customized forms for
        data processing and it also provides the ability to create new fields or modify existing ones. Currently the
        following general fields are available:
        <itemizedlist>
            <listitem><para>Text</para></listitem>
            <listitem><para>Integer</para></listitem>
            <listitem><para>Float</para></listitem>
            <listitem><para>Date and Time</para></listitem>
            <listitem><para>List</para></listitem>
            <listitem><para>Checkbox</para></listitem>
            <listitem><para>Radio Buttons</para></listitem>
        </itemizedlist>

        Based on the fields listed above, there are fields which serve a more specific role also:
        <itemizedlist>
            <listitem><para>Blood Pressure</para></listitem>
            <listitem><para>Social Security Number</para></listitem>
            <listitem><para>Phone Number</para></listitem>
        </itemizedlist>
        All available fields can be seen in &explorer-name;:
        </para>
            <mediaobject>
            <imageobject align="left">
                <imagedata fileref="./resources/images/dialogs/ace-fields.jpg" format="JPEG"/>
            </imageobject>
            </mediaobject>
        <para>
        Every type of field available has its own both client-side and server-side validation
        features. For example, an integer field allows only numerical values into the field and
        a social security number field only allows dashes and numeric digits. Aside from using the
        built-in fields, &product-name; provides a way to create new fields using the &framework-name;'s
        Java class called <classname>com.xaf.form.DialogField</classname>. The following is a sample
        class definition for creating a dialog field:
        <programlisting>
            <![CDATA[
import com.xaf.form.*;

public class NewField extends com.xaf.form.DialogField
{
    ...
    ..
}
            ]]>
        </programlisting>
        The following XML entry must be added to the dialog's package so that the dialog can access
        the field. The following is an example of a dialog using the <classname>NewField</classname>:
        <programlisting>
            <![CDATA[
    <dialogs package="Test">
        <register-field class="NewField" tag-name="field.newfield"/>
        <dialog name="TestNewField" heading="Test New Field">
            <field.newfield name="new_field" caption="My New Field" ... />
            ....
            ...
        </dialog>
    </dialogs>
            ]]>
        </programlisting>
        As shown above, the XML tag <sgmltag class="element">register-field</sgmltag> is used to register
        the new field. The attribute <sgmltag class="attribute">class</sgmltag> is used to define the
        Java class for the new field and the <sgmltag class="attribute">tag-name</sgmltag> attribute
        is used to define the XML tag name.
        <note>
            <para>
            Any new field being created must have an XML element name that beings
            with <quote>field.</quote>
            </para>
        </note>
        </para>

        <section>
            <title> Examples </title>
            <para>
            <example>
                <title>Text, Static, Integer, Float, SSN, and Zip fields</title>
                <para>
                The following is an example of a dialog containing general fields such as text, static, integer,
                float and specialized fields such as social security number and zip code.
                <programlisting>
                <![CDATA[
<dialog  name="Test1" heading="Test Fields" retain-params="*">
    <field.separator heading="Text Fields"/>
    <field.text name="text_field_hidden" hidden="yes" default='request:id'/>
    <field.static name="static_field" default='Static Field'/>
    <field.text name="text_field_required" caption="Text Required"
        hint="Text field required" required="yes"/>
    <field.text name="text_field" caption="Text" hint="Text field optional"
        max-length="5" uppercase="yes"/>
    <field.text name="text_field_email" caption="Text Email"
        hint="Text field with regular expression checking"
        validate-pattern="/^\w+((-\w+)|(\.\w+))*\@[A-Za-z0-9]+((\.|-)[A-Za-z0-9]+)*\.[A-Za-z0-9]+$/"
        validate-msg="Invalid email format."/>
    <field.email name="email_field" caption="Email"/>
    <field.ssn name="ssn_field" caption="SSN"/>

    <field.separator heading="Numeric Fields"/>
    <field.integer name="integer_field" caption="Integer Field" hint="Integer field"/>
    <field.float name="float_field" caption="Float Field" hint="Float field"/>
    <field.zip name="zip_field" caption="Zip Field" hint="Zip code field"/>
    <director submit-caption="Submit"/>
</dialog>
                ]]>
                </programlisting>
                The above example contains multiple fields of various types and some of the attributes available for
                the different types. The attribute <sgmltag class="attribute">retain-params</sgmltag> of the
                <sgmltag class="element">dialog</sgmltag> tag is useful for retaining field values (whether they were
                entered by the user or from value sources) as the dialog goes through its different stages before execution.
                The default values for the dialog fields can be empty or they can be specified in the
                XML file. The attribute <sgmltag class="attribute">default</sgmltag> is available for specifying
                the default value and it can either be a static value or it can be a value source. In the example above, the hidden
                text field called <emphasis>text_field_hidden</emphasis> gets its value from a request parameter
                value source while the static field called <emphasis>static_field</emphasis> gets its value
                as a plain string. Most dialog fields have an attribute called <sgmltag class="attribute">hint</sgmltag> which
                is used to display a helpful hint for the user on what to enter into the field.

                The following is a screenshot of how the actual dialog looks like:
                </para>
                <para>
                    <mediaobject>
                    <imageobject align="left">
                        <imagedata fileref="./resources/images/dialogs/test1.jpg" format="JPEG"/>
                    </imageobject>
                    </mediaobject>
                </para>
            </example>

            <example>
                <title>Memo, Date &amp; Time, Boolean fields</title>
                <para>
                The following is a definition for a dialog which contains a memo field, several versions
                of the date and time field, and several versions of the boolean field:
                <programlisting>
                <![CDATA[
<dialog name="Test2" heading="Test Fields" retain-params="*">
    <field.separator name="Memo" heading="Memo"/>
    <field.memo name="memo_field_01" caption="Memo Field"
        max-length="5"
        hint="Max length is 5 characters"/>
    <field.separator name="date_time_section" heading="Date and Time Fields"/>
    <field.duration name="duration" caption="Duration Field"
        hint="Format is MM/dd/yyyy"/>
    <field.date name="date_field_strict" caption="Date (Strict Year)"
        format="MM-dd-yyyy"
        default="today"
        hint="Format is MM-dd-yyyy"/>
    <field.date name="date_field_nonstrict" caption="Date (Non-Strict Year)"
        format="MM/dd/yyyy"
        strict-year="no"
        default="today+1"
        hint="Format is MM/dd/yyyy"/>
    <field.time name="time_field" caption="Time"
        initial-focus="yes"
        default="now"
        hint="Format is HH:mm"/>
    <field.separator heading="Boolean Fields"/>
    <field.boolean name="bool_field_radio" caption="Boolean Field (Radio)" style="radio"/>
    <field.boolean name="bool_field_alone" caption="Boolean Field (Alone)" style="checkalone"/>
    <field.boolean name="bool_field_combo" caption="Boolean Field (Combo)" style="combo"/>
    <director submit-caption="Submit"/>
</dialog>
                ]]>
                </programlisting>
                <variablelist>
                    <varlistentry>
                        <term> <sgmltag class="element">field.memo</sgmltag> </term>
                        <listitem>
                            <para>
                            The <sgmltag class="element">field.memo</sgmltag> is based on the HTML TEXTAREA element
                            and the attribute <sgmltag class="attribute">max-length</sgmltag> is used to enforce
                            the maximum number of characters allowed in the memo field. Javascript client-side validations
                            are done to enforce the maximum number of characters allowed.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term> <sgmltag class="element">field.duration</sgmltag> </term>
                        <listitem>
                            <para>
                            The duration field, <sgmltag class="element">field.duration</sgmltag>, is used to
                            allow entry of  a begin date and an end date. It has client-side validations to make sure
                            that the date values are valid and that beginning date field is before the end date field.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term> <sgmltag class="element">field.date</sgmltag> </term>
                        <listitem>
                            <para>
                            By default date fields, <sgmltag class="element">field.date</sgmltag> do not allow 2-digit years
                            and this can be changed by setting the attribute <sgmltag class="attribute">strict-year="no"</sgmltag>.
                            Also the format of a date field can be specified by setting the attribute
                            <sgmltag class="attribute">format</sgmltag>. The value for <sgmltag class="attribute">format</sgmltag>
                            is based on the <classname>java.text.SimpleDateFormat</classname>'s pattern strings. The date field
                            also has a built-n client-side formatting feature which will automatically format the user
                            entered value: user enters 11021999 and it gets displayed as 11/02/1999. The default value
                            of the date field accepts special strings such as "<emphasis>today</emphasis>" and "<emphasis>now</emphasis>"
                            and interprets them as present date. Any numerical operation defined after the special string
                            is used to recalculate the default date (for example, "<emphasis>today+1</emphasis>" will
                            display tomorrow's date)
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term> <sgmltag class="element">field.time</sgmltag> </term>
                        <listitem>
                            <para>
                            The time field, <sgmltag class="element">field.time</sgmltag>, is used to
                            allow entry of  a time value. It has client-side validations to make sure
                            that the time entered is valid. It also accepts the special string
                            "<emphasis>now</emphasis>" as a default value.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term> <sgmltag class="element">field.boolean</sgmltag> </term>
                        <listitem>
                            <para>
                            The boolean field, <sgmltag class="element">field.boolean</sgmltag>, represents
                            different HTML elements: a single checkbox, a Yes/No select list, and a Yes/No radio buttons.
                            These different elements are represented by the <sgmltag class="attribute">style</sgmltag>
                            attribute with the following values respectively: <emphasis>radio</emphasis>,
                            <emphasis>checkalone</emphasis>, and <emphasis>combo</emphasis>. A "No" selection
                            submits a value of 0 and a "Yes" selection submits a value of 1.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>

                The XML definition above is shown as:
                </para>
                <para>
                    <mediaobject>
                    <imageobject align="left">
                        <imagedata fileref="./resources/images/dialogs/test2.jpg" format="JPEG"/>
                    </imageobject>
                    </mediaobject>
                </para>
            </example>
            <example>
                <title>Select fields</title>
                <para>
                    The following is a XML definition example to show the different styles available for
                    select fields:
                    <programlisting>
                    <![CDATA[
<dialog name="Test3" heading="Test Fields" retain-params="*">
    <field.separator heading="Select Fields" />
    <field.select name="sel_field_combo" read-only="no" caption="Select Field (Combo)"
        style="combo" choices="Choice 1=A;Choice 2=B;Choice 3=C" prepend-blank="yes" append-blank="yes"
        />
    <field.select name="sel_field_radio" read-only="no" caption="Select Field (Radio)"
        style="radio" choices="Choice 1=A;Choice 2=B;Choice 3=C" default="A"/>
    <field.select name="sel_field_list" read-only="no" caption="Select Field (List)"
        style="list" size="5" choices="Choice 1=A;Choice 2=B;Choice 3=C" default="A"/>
    <field.select name="sel_field_multilist" read-only="no" caption="Select Field (MultiList)"
        style="multilist" size="5" choices="Choice 1=A;Choice 2=B;Choice 3=C"
        default="A"/>
    <field.select name="sel_field_multicheck" read-only="no" caption="Select Field (MultiCheck)"
        style="multicheck" choices="Choice 1=A;Choice 2=B;Choice 3=C" default="B"/>
    <field.select name="sel_field_multidual" read-only="no" caption="Select Field (MultiDual)"
        style="multidual" choices="Choice 1=A;Choice 2=B;Choice 3=C" caption-left="Left Caption"
        caption-right="Right Caption" multi-width="100"
        default="A"/>
     <director submit-caption="Submit"/>
</dialog>
                    ]]>
                    </programlisting>
                    The XML tag, <sgmltag class="element">field.select</sgmltag>, is based upon the
                    SELECT HTML element. It can be used as a list capable of allowing the user to choose
                    one selection or multiple selections based on the configuration. There are six styles
                    of selection list available (<emphasis>combo</emphasis>, <emphasis>radio</emphasis>, <emphasis>list</emphasis>,
                    <emphasis>multilist</emphasis>, <emphasis>multicheck</emphasis>, and <emphasis>multidual</emphasis>)
                    and they can be defined using the <sgmltag class="attribute">style</sgmltag>
                    attribute. The <emphasis>multilist</emphasis>, <emphasis>multicheck</emphasis>, and
                    <emphasis>multidual</emphasis> styles allow a selection of more than one option.
                </para>
                <para>
                    The choices available for a selection are defined by the <sgmltag class="attribute">choices</sgmltag>
                    attribute. The syntax for the choices is <emphasis>choice_1=value_1;choice_2=value_2;...</emphasis>
                    where the <emphasis>choice_x</emphasis> is the displayed choice and the <emphasis>value_x</emphasis>
                    is the actual value that is submitted.

                    There is another way to define the choices available for a selection and it is by using
                    a value source called <emphasis>query</emphasis>. This way builds the option list from
                    the result of a static query (the query must be defined in <filename class="conf">WEB-INF/ui/statement.xml</filename>).
                    For example, the following SQL can be used as <emphasis>choices="query:test.user_list</emphasis>
                    attribute setting:
                    <programlisting>
                    <![CDATA[
<sql-statements package="test">
    <statement name="user_list">
        select
            name,
            id
        from User
    </statement>
</sql-statements>
                    ]]>
                    </programlisting>
                    The above SQL's <emphasis>name</emphasis> and <emphasis>id</emphasis> result
                    will be used to construct a choice list with the <emphasis>name</emphasis> entry
                    being the displayed string and the corrsponding <emphasis>id</emphasis> being the
                    submitted value.

                    There are two other attributes that effect the display
                    of the choices for selection and they are <sgmltag class="attribute">prepend-blank</sgmltag>
                    and <sgmltag class="attribute">append-blank</sgmltag>. The functionality of these two attributes
                    is to prepend a blank to the choice list and to append a blank to the choice list respectively.
                    The following is a screenshot of the dialog defined above:
                </para>
                <para>
                    <mediaobject>
                    <imageobject align="left">
                        <imagedata fileref="./resources/images/dialogs/test3.jpg" format="JPEG"/>
                    </imageobject>
                    </mediaobject>

                </para>
            </example>
            <example>
                <title>Conditional fields</title>
                <para>
                    &framework-name; provides a dynamic field displaying and hiding functionality which is
                    defined by the <sgmltag class="element">conditional </sgmltag> XML element. The following
                    is an example dialog definition:
                    <programlisting>
                    <![CDATA[
        <dialog name="Test6" heading="Test Conditionals" loop="yes">
            <field.select name="sel_field_list" caption="Select Field (Combo)" style="combo"
                size="5" choices="-;Choice 1=A;Choice 2=B;Choice 3=C"/>
            <field.text name="text_field" caption="Hidden Text" default="Here I am!">
                <conditional action="display" partner="sel_field_list"
                 js-expr="control.selectedIndex != 0"/>
            </field.text>
            <field.boolean name="checkbox_field" caption="Checkbox" style="checkalone" />
            <field.static name="static_field2" default="Checkbox checked!">
                <conditional action="display" partner="checkbox_field"
                 js-expr="control.checked == true"/>
            </field.static>
        </dialog>
                    ]]>
                    </programlisting>
                    In the above example, the text field named <emphasis>text_field</emphasis> is dependent upon the select field
                    named <emphasis>sel_field_list</emphasis>. This is done by adding the <sgmltag class="element">conditional </sgmltag>
                    element as a child node to the text field and setting the attribute <sgmltag class="attribute">partner</sgmltag>
                    to the name of the select field. The condition for displaying the text field is created by setting the
                     <sgmltag class="attribute">js-expr</sgmltag> (Javascript expression) attribute. In the definition above,
                     the text field named <emphasis>text_field</emphasis> will only be displayed if the selected option of the
                     <emphasis>sel_field_list</emphasis> is not the first option.
                 </para>

                 <para>
                     The second conditional field of the dialog is a static field named <emphasis>static_field</emphasis>
                     and its' display status is dependent upon the <emphasis>checkbox_field</emphasis> being "checked". The
                     following is a screen shot of the initial stage of the dialog:
                </para>
                <para>
                    <mediaobject>
                    <imageobject align="left">
                        <imagedata fileref="./resources/images/dialogs/test6_1.jpg" format="JPEG"/>
                    </imageobject>
                    </mediaobject>
                </para>
                <para>
                    The following is a screen shot of the dialog after the select field's selection has been changed:
                </para>
                <para>
                    <mediaobject>
                    <imageobject align="left">
                        <imagedata fileref="./resources/images/dialogs/test6_2.jpg" format="JPEG"/>
                    </imageobject>
                    </mediaobject>
                </para>
                <para>
                    The following is a screen shot of the dialog after the checkbox has been checked:
                </para>
                <para>
                    <mediaobject>
                    <imageobject align="left">
                        <imagedata fileref="./resources/images/dialogs/test6_3.jpg" format="JPEG"/>
                    </imageobject>
                    </mediaobject>
                </para>
                <para>
                Aside from the <sgmltag class="attribute">action</sgmltag> attribute, there are other useful attributes
                available such as <sgmltag class="attribute">apply-flag</sgmltag> and <sgmltag class="attribute">clear-flag</sgmltag>.
                The more common values for these two attributes are <sgmltag class="attvalue">invisible</sgmltag>, 
                <sgmltag class="attvalue">read-only</sgmltag>, and <sgmltag class="attvalue">browser-read-only</sgmltag>.
                For setting or removing these flags depend upon other attributes such as <sgmltag class="attribute">
                data-cmd</sgmltag>, <sgmltag class="attribute">has-permission</sgmltag>, and <sgmltag class="attribute">
                lack-permission</sgmltag>. 
                </para>
            </example>

            <example>
                <title>Popup field</title>
                <para>
                    &product-name; provides a feature to display a popup dialog box when a popup icon
                    is clicked and values from a selection in the popup can be returned to the main window.
                    The following XML definition creates a field that has a popup dialog associated with it:
                    <programlisting>
                    <![CDATA[
    <dialog name="Test7" heading="Test Popup" loop="yes">
        <field.text name="text_field_1" caption="Text Field 1" />
        <field.text name="text_field_2" caption="Text Field 2" read-only="browser"
            hint="Click on the icon to select a value">
            <popup action="create-app-url:/textJS.html" fill="text_field_1,text_field_2"/>
        </field.text>
    </dialog>
                ]]>
                    </programlisting>
                    The above example displays a dialog with a text field named <emphasis>text_field_2</emphasis>
                    which cannot be filled in by the user but can only be filled in from a popup box associated with it.
                    By clicking on the popup icon (<inlinemediaobject><imageobject align="left"><imagedata fileref="../../resources/images/dialog/magnifying-glass-sm.gif" format="GIF"/></imageobject></inlinemediaobject>)
                    the URL defined as the action, <literal>textJS.html</literal>, will be displayed in a popup window.
                    The process through a value or multiple values  being returned into the <emphasis>text_field_2</emphasis>
                    is to invoke a Javascript method called <literal>populateValues()</literal> provided by &product-name;.
                    The following is an example of a HTML string to invoke the Javascript method:
                    <programlisting>
                    <![CDATA[
    <input type="button" value="OK" onClick="populateValues('This is the filled in text!');"/>
                    ]]>
                    </programlisting>
                </para>
            </example>
        </para>
        </section>
    </section>


    <section id="Dialogs-Skins">
        <title>Look &amp; Feel: Skins</title>
        <para>
        Skins provide consistent look and feel and allows the same code to run on a variety of
        browsers and platforms (e.g. hand-helds). Skins are defined in
        <filename class="conf">WEB-INF/ui/dialog.xml</filename> with the XML tag
        <emphasis role="bold"> &lt;dialog-skin&gt;</emphasis>. The following is an example
        of how a skin is defined:
        <programlisting>
        <![CDATA[
    <dialog-skin name="TestSkin">
        <outer-table-attrs>
            cellspacing='5' cellpadding='5' border='5'
        </outer-table-attrs>
        <frame-head-row-attrs>
            bgcolor='#6495ed'
        </frame-head-row-attrs>
        <caption-cell-attrs>
            style='font-family: Andale Mono'
        </caption-cell-attrs>
        <include-pre-script src="/test/script.js"/>
        <include-post-script src="/test/script-post.js"/>
        <append-post-script> alert(activeDialog);   </append-post-script>
    </dialog-skin>
        ]]>
        </programlisting>
        The created skin can be used by a dialog in a JSP:
        <programlisting>
            <![CDATA[
     <xaf:dialog name="Test.Test1" skin="TestSkin"/>
            ]]>
        </programlisting>
        <note>
        <para>
        Refer to <xref linkend="Using-Dialog"/> for the complete description on how
        to use the <emphasis role="bold">&lt;xaf:dialog&gt;</emphasis> tag.
        </para>
        </note>

        The following is a screenshot of the dialog with the default skin:
        </para>

        <para>
        <mediaobject>
        <imageobject align="left">
            <imagedata fileref="./resources/images/dialogs/skin1.jpg" format="JPEG"/>
        </imageobject>
        </mediaobject>
        </para>

        <para>
        The following is a screenshot of the dialog after the <emphasis>TestSkin</emphasis>
        was configured:
        </para>

        <para>
        <mediaobject>
        <imageobject align="left">
            <imagedata fileref="./resources/images/dialogs/skin2.jpg" format="JPEG"/>
        </imageobject>
        </mediaobject>
        </para>
    </section>

    <section id="Dialogs-DataCommands">
        <title>Data Commands</title>
        <para>
        One of the common usage of dialogs is to create, modify, and delete the same data such as users,
        orders, and contact information. The differences between these dialogs are minor in a sense that
        they all tend to display the same fields (but in different modes such as read-only or invisible). 
        To avoid defining the same dialog three times (with slight variations in field attributes) just to 
        provide create, edit, and delete functionality of the same data, &framework-name; provides 
        a feature called <emphasis class="bold">data commands</emphasis>. A dialog functions differently
        based upon the data command it receives; for example, it can display fields as read only when
        the data command is delete and it can hide some fields when the data command is create.
        As hinted above, &framework-name; dialogs recognizes three types of data commands: <emphasis>add</emphasis>,
        <emphasis>edit</emphasis>, and <emphasis>delete</emphasis>.
        </para>
        
        <para>
        Data commands are recognized by the dialog in two ways: as a request parameter or as a request attribute  
        called <varname>data_cmd</varname>. The dialog behaves in different ways according to the data command by 
        changing the name of the submit action button and also making all the fields read only for the <emphasis>delete</emphasis> mode. 
        By default, there is very little difference in the behavior of the dialog when it is in either the 
        <emphasis>add</emphasis> or <emphasis>edit</emphasis>. The funtionality of the <emphasis>add</emphasis> or 
        <emphasis>edit</emphasis> modes are enhanced more through the power of the conditional fields assigned to the
        dialog. Conditional fields can be configured to depend upon the mode the dialog is in so that fields
        can be read-only or invisible.
        
        <example>            
            <title>Conditional fields dependent upon the Dialog's data mode</title>
            <para> 
            <programlisting>
            <![CDATA[
    <dialog name="registration" heading="create-data-cmd-heading:Account" retain-params="org_id">
        <field.debug visible="no"/>
        <field.text name="org_code" caption="Account Code" required="yes"/>
        <field.text name="org_name" caption="Name" required="yes"/>
        <field.text name="org_abbrev" caption="Abbreviation"/>
        <field.select name="org_type" caption="Type" choices="schema-enum:Org_Type_Enum">
            <conditional action="apply-flag" flag="invisible" data-cmd="edit,delete"/>
        </field.select>
        <field.select name="org_industry" caption="Industry" choices="schema-enum:Org_Industry_Enum">
            <conditional action="apply-flag" flag="invisible" data-cmd="edit,delete"/>
        </field.select>            
        ...
    </dialog>
            ]]>
            </programlisting>
            In the above dialog definition, the select field <sgmltag class="attvalue">org_type</sgmltag> and 
            <sgmltag class="attvalue">org_industry</sgmltag> has conditions defined based upon the mode of the dialog.
            When the dialog is in edit or delete mode, the <emphasis>invisible</emphasis> flag is applied to
            the fields. For more information on conditional fields, go to <xref linkend="Dialogs-DataFields"/>.
            </para>
        </example>
        </para>
    </section>

    <section id="Testing-Dialog">
        <title>Testing the dialog</title>
        <section>
            <title>Unit Testing</title>
            <para>
            All dialogs defined in <filename class="conf">WEB-INF/ui/dialog.xml</filename>
            are listed in &explorer-name; under
            <menuchoice role="bold">
                <guimenu>Application</guimenu>
                <guimenuitem>Dialogs</guimenuitem>
            </menuchoice>    menu item.
            </para>

            <para>
            <mediaobject>
            <imageobject align="left">
                <imagedata fileref="./resources/images/dialogs/ace-dialogs.jpg" format="JPEG"/>
            </imageobject>
            </mediaobject>
            </para>

            <para>
            Clicking on the Action (<imageobject><imagedata fileref="../../resources/images/ace/icons/exec_dialog.gif" format="GIF"/>
            </imageobject>) icon of any dialog displays a test page with the dialog in it.
            Each dialog can be tested by entering values for the dialog and then pressing the OK button:
            </para>

            <para>
            <mediaobject>
            <imageobject align="left">
                <imagedata fileref="./resources/images/dialogs/ace-testdialog.jpg" format="JPEG"/>
            </imageobject>
            </mediaobject>
            </para>

            <para>
            This will display the entered values:
            </para>

            <para>
            <mediaobject>
            <imageobject align="left">
                <imagedata fileref="./resources/images/dialogs/ace-testresult.jpg" format="JPEG"/>
            </imageobject>
            </mediaobject>
            </para>
        </section>
    </section>

    <section id="Using-Dialog">
        <title>Using the dialog</title>
        <para>
            &product-name; provides convenient yet flexible ways to use and enhance the behavior of
            Dialog objects. The most common usage of a dialog is to define the dialog in the
            <filename class="conf">WEB-INF/ui/dialog.xml</filename> file and then to use the JSP
            custom tag <emphasis role="bold">&lt;xaf:dialog&gt;</emphasis> to invoke the dialog.
            <programlisting>
        <![CDATA[
    <xaf:dialog name="test.Test1"/>
        ]]>
            </programlisting>
            This utilizes the built-in functionality and behavior of a &product-name; dialog. The user does not
            need to be concerned with various processes of a HTML form submittal such as
            data validations, verifying the correct stage execution (blocking redundant submittals), and
            processing the form's action.

            The common way to define an action for a dialog is to insert the action items within the
            dialog's start and end tags:
            <programlisting>
        <![CDATA[
         <xaf:dialog name="test.Test1">
            <xaf:query name="MyQuery" skin="report"/>
         </xaf:dialog>
        ]]>
            </programlisting>
            The above snippet of JSP code describes a dialog which will execute a SQL query when it is
            submitted. Instead of a query, one can also write pure Java code:
            <programlisting>
        <![CDATA[
     <xaf:dialog name="test.Test1">
        <%
            response.sendRedirect("/home");
        %>
     </xaf:dialog>
    ]]>
            </programlisting>
            Everything within the dialog custom tags (HTML, Java code, custom tags) are considered the
            action of the dialog.
        </para>
        <para>
            Usually, the action of the dialog is defined outside of the
            definition of the dialog such as in the JSP but there is a way to define
            an action for a dialog within the <filename class="conf">WEB-INF/ui/dialog.xml</filename>.
            The following is an example:
            <programlisting>
    <![CDATA[

    <dialog name="Test4" heading="Test Fields" loop="yes" retain-params="*">
        <field.report name="report_field">
            <statement name="list">
                select 0 as "checkbox", userid as "ID", lname as "Name"
                from users

                <report skin="eimo-report">
                    <column type="checkbox" align="center" field-name="my_name" field-value="my_name_row_${1}"/>
                    <column heading="ID" output="abc% $ ${2}" format="%"/>
                    <column heading="Last Name" url="create-app-url:/${2}" calc="count"/>
                </report>
            </statement>
        </field.report>
    </dialog>
    ]]>
            </programlisting>
        </para>
        <section>
            <title>Using listeners</title>
            <para>
            &product-name; provides a way to implement business logic into the behavior
            of a dialog by providing a feature called <emphasis>Listeners</emphasis>.
            A listener is a Java object which is invoked when state changes occur in a dialog.
            It contains various behavior methods such as execution, data
            validation, and data population. All listeners must extend &framework-name;'s
            listener class <classname>com.xaf.form.DefaultDialogContextListener</classname>.
            The following is an example of a listener used in a JSP:
            <programlisting>
    <![CDATA[
    request.setAttribute
    ("test-listener", new DefaultDialogContextListener()
        {
            public boolean isDialogValid(DialogContext dc, boolean fieldsAlreadyValidated)
            {
                // insert code here to validate dialog
            }
        }
    );

    <xaf:dialog name="Test.Test1" listener="test-listener"/>

    ]]>
            </programlisting>
            In the example above, the <emphasis>test-listener</emphasis>'s  <methodname>isDialogValid</methodname> method is
            called when the dialog needs to check validity of data, before the dialog
            has performed its own validation.
            </para>
        </section>

        <section>
            <title>Defining a customized Java Dialog class</title>
            <para>
            There could be times when the total built-in behavior of a dialog does not satisfy the requirements
            of a web application; thus &product-name; provides a way to create a dialog
            object in Java.
            A dialog can be created using a Java class which
            must extend the &framework-name;'s dialog class called
            <classname>com.xaf.form.Dialog</classname>:
            <programlisting>
            <![CDATA[
package Test;

public class Test1  extends com.xaf.form.Dialog
{
    ...
    ..
}
            ]]>
            </programlisting>
            The behavior of the dialog can then be modified by overwriting the methods available or introducing new methods.
            The new dialog class can then be used by associating the class with a dialog
            definition in <filename class="conf">WEB-INF/ui/dialog.xml</filename> file:
            <programlisting>
            <![CDATA[
        <dialog name="TestDialog" heading="Test Dialog" class="Test.Test1">
            ...
            ..
        </dialog>
            ]]>
            </programlisting>
            </para>
        </section>
    </section>

    <section id="Dialog-Context">
        <title> Dialog Context</title>
        <para>
        &framework-name;'s Dialog component's functionality with respect to action and listener executions mentioned
        in the previous section is controlled through a class called <classname>com.xaf.form.DialogConext</classname>.
        The class can be considered as a controller of the dialog component providing different functions such as
        execution validations, error message creations, stage tracking, and dialog value populations.
        The following is a diagram of how the dialog context fits into the flow of a web application:        
        </para>
        <para>
        <mediaobject>
        <imageobject align="left">
            <imagedata fileref="./resources/images/dialogs/dialogcontext.jpg" format="JPEG"/>
        </imageobject>
        </mediaobject>
        </para>        
        <para>
        A dialog context is created using the <methodname>createContext</methodname> method of the 
        <classname>Dialog</classname> class and it is created for each dialog. The values within the dialog
        and the properties of the dialog is tracked through its' dialog context. For example,
        there are three main stages (<literal>input</literal>, <literal>validate</literal>, <literal>execute</literal>) 
        that a dialog goes through and the flow of these stages are controlled by the dialog context. 
        Only when the data has been validated, the dialog context changes the state of the dialog
        to execution mode and allows the configured or programmed actions to be executed. At any time
        a dialog context is needed to access any of the dialog's fields. A dialog context also contains
        many ways to access and use SQL statements and database transactions from the dialog.
        </para>
        
        <section>
            <title>Using the dialog context</title>
            <para>
            For simple web applications, there will be no need to use the <classname>DialogContext</classname>
            object. The extensive functionality of the <classname>DialogContext</classname> will
            probably be unused beyond the basic method calls made by the <classname>Dialog</classname> object.
            If there is a need to use other functionalitites provided by the <classname>DialogContext</classname>
            class or to extend the existing functionalities,        
            &framework-name; allows the dialog context of any dialog to be overwritten or subclassed. 
            A simple subclassing of the dialog context is shown below:
            <programlisting>
            <![CDATA[            
public class Test1Context extends com.xaf.form.DialogContext
{
    ...
}
            ]]>
            </programlisting>
            The above class can then be used by referenceing it in the dialog configuration file <filename>dialog.xml</filename>:
            <programlisting>
            <![CDATA[
<dialog  name="Test1" heading="Test Fields" retain-params="*" dc-class="Test1Context">               
            ]]>
            </programlisting>
            
            
            It is <quote>possible</quote> to think of the dialog context as a bean representation of a dialog object. Every field
            and its properties configured in a dialog object can be accessed using various methods (including set and get methods)
            as shown below:
            </para>

            <para>        
            <emphasis role="bold">XML (<filename>dialog.xml</filename>):</emphasis>
            <programlisting>
            <![CDATA[
<dialog  name="Test1" heading="Test Fields" retain-params="*">        
    ...
    <field.phone name="phone_field" caption="Phone Field"  strip-brackets="yes" 
        format-type="dash" hint="Phone field"/>        
    ...
</dialog>    
            ]]>
            </programlisting>

            <emphasis role="bold">Java (<filename>Test1Context.java</filename>):</emphasis>
            <programlisting>
            <![CDATA[    
public class Test1Context extends DialogContext
{
    ...
    public boolean isPhoneFieldValueSet() { return hasValue("phone_field"); }
    public boolean isPhoneFieldFlagSet(long flag) { return flagIsSet("phone_field", flag); }
    public void setPhoneFieldFlag(long flag) { setFlag("phone_field", flag); }
    public void clearPhoneFieldFlag(long flag) { clearFlag("phone_field", flag); }
    public String getPhoneFieldRequestParam(long flag) { return request.getParameter("_dc.phone_field"); }
    public DialogField getPhoneFieldField() { return getField("phone_field"); }
    public DialogContext.DialogFieldState getPhoneFieldFieldState() { return getFieldState("phone_field"); }
    public void addPhoneFieldErrorMsg(String msg) { addErrorMessage("phone_field", msg); }
    public String getPhoneField() { return getValue("phone_field"); }
    public String getPhoneField(String defaultValue) { return getValue("phone_field", defaultValue); }
    public String getPhoneFieldOrBlank() { return getValue("phone_field", ""); }
    public void setPhoneField(String value) { setValue("phone_field", value); }        
    ...
}   
        ]]>
            </programlisting>

            The above class is a &explorer-name; generated dialog context subclass for the <literal>Test1</literal>
            dialog. &framework-name; has the ability to generate a dialog context specific to a dialog through
            &explorer-name;. In the Dialog page (
            <menuchoice>
                <guimenu>Application</guimenu>
                <guimenuitem>Dialogs</guimenuitem>
            </menuchoice> menu item)
            there is a URL called <literal>Generate Dialog Beans</literal> which generates a dialog context
            object for each dialog configured in <filename>dialog.xml</filename>. Once the dialog context
            classes have been generated, they will be automatically used as the <classname>DialogContext</classname>
            class of its' respective dialog. A developer can either use this generated dialog context class or
            a new class can be created by subclassing this generated class. 
            </para>
        </section>                

    </section>
</chapter>